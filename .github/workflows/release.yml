# Release Workflow
# ================
# Triggered on version tags (v*). Builds and publishes to all distribution channels.
#
# VERSIONING
# ----------
# Using semver 0.x.y until stable. All releases are published to all channels.
# Version 1.0.0 will be the first stable release.
#
# DISTRIBUTION CHANNELS
# ---------------------
# | Channel      | Repo/Registry                          | Auto-update |
# |--------------|----------------------------------------|-------------|
# | Binaries     | GitHub Releases                        | ✓           |
# | Cargo        | crates.io                              | ✓           |
# | npm (wasm)   | @rustledger/wasm                       | ✓           |
# | npm (mcp)    | @rustledger/mcp-server                 | ✓           |
# | Docker       | ghcr.io/rustledger/rustledger          | ✓           |
# | Homebrew     | rustledger/homebrew-rustledger         | ✓           |
# | Scoop        | rustledger/scoop-rustledger            | ✓           |
# | AUR          | aur.archlinux.org/rustledger{,-bin}    | ✓           |
# | nixpkgs      | NixOS/nixpkgs (PR)                     | ✓           |
# | COPR         | copr.fedorainfracloud.org/rustledger   | ✓           |
# | PPA          | ppa:rustledger/rustledger              | ✓           |
#
# SECRETS REQUIRED
# ----------------
# - CARGO_REGISTRY_TOKEN: crates.io publish
# - WEBSITE_DISPATCH_TOKEN: Homebrew/Scoop/nixpkgs automation
# - AUR_SSH_PRIVATE_KEY: AUR push access
# - COPR_API_TOKEN: COPR build trigger (from copr.fedorainfracloud.org/api)
# - LAUNCHPAD_SSH_PRIVATE_KEY: Launchpad upload access
# - LAUNCHPAD_GPG_PRIVATE_KEY: PPA package signing
# - (npm uses OIDC trusted publishing, no token needed)
#
name: Release
on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to release (e.g., v0.1.0)'
        required: true
        type: string
permissions:
  contents: write
  id-token: write # Required for npm trusted publishing (OIDC)
  packages: write # Required for GitHub Container Registry
env:
  CARGO_TERM_COLOR: always
  # Use input tag for workflow_dispatch, otherwise use the pushed tag
  RELEASE_TAG: ${{ inputs.tag || github.ref_name }}
jobs:
  build:
    name: Build ${{ matrix.target }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux (glibc) - PGO enabled for native target
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            pgo: true
          - target: aarch64-unknown-linux-gnu
            os: ubuntu-latest
            cross: true
          # Linux (musl - static binaries) - cross-compiled, no PGO
          - target: x86_64-unknown-linux-musl
            os: ubuntu-latest
            cross: true
          - target: aarch64-unknown-linux-musl
            os: ubuntu-latest
            cross: true
          # macOS - PGO enabled for both architectures
          - target: x86_64-apple-darwin
            os: macos-13  # Intel runner for x86_64
            pgo: true
          - target: aarch64-apple-darwin
            os: macos-latest  # ARM runner
            pgo: true
          # Windows - PGO enabled for x86_64
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            pgo: true
          - target: aarch64-pc-windows-msvc
            os: windows-latest
            # No PGO - can't run ARM binary on x86 runner
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_TAG }}
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
          components: llvm-tools-preview
      - name: Install cross
        if: matrix.cross
        uses: taiki-e/install-action@cross
      - name: Install cargo-pgo
        if: matrix.pgo
        run: cargo install cargo-pgo
      - name: Generate benchmark for PGO (Unix)
        if: matrix.pgo && runner.os != 'Windows'
        run: |
          # Generate a representative workload for PGO profiling
          python3 << 'EOF'
          import random
          from datetime import date, timedelta
          import os
          random.seed(42)
          accounts = [
              "Assets:Bank:Checking", "Assets:Bank:Savings", "Assets:Investments:Stocks",
              "Liabilities:CreditCard", "Expenses:Food:Groceries", "Expenses:Food:Restaurant",
              "Expenses:Transport:Gas", "Expenses:Utilities:Electric", "Income:Salary", "Equity:Opening-Balances",
          ]
          benchmark_path = os.path.join(os.environ.get('RUNNER_TEMP', '/tmp'), 'benchmark.beancount')
          with open(benchmark_path, "w") as f:
              f.write('option "operating_currency" "USD"\n\n')
              for acc in accounts:
                  f.write(f"2020-01-01 open {acc}\n")
              f.write("\n")
              start_date = date(2020, 1, 1)
              for i in range(10000):
                  d = start_date + timedelta(days=i // 10)
                  amount = round(random.uniform(5, 500), 2)
                  expense = random.choice([a for a in accounts if a.startswith("Expenses:")])
                  source = random.choice(["Assets:Bank:Checking", "Liabilities:CreditCard"])
                  f.write(f'{d} * "Payee {i % 100}" "Transaction {i}"\n')
                  f.write(f"  {expense}  {amount} USD\n")
                  f.write(f"  {source}\n\n")
          print(f"Generated benchmark at {benchmark_path}")
          EOF
      - name: Generate benchmark for PGO (Windows)
        if: matrix.pgo && runner.os == 'Windows'
        shell: pwsh
        run: |
          $benchmarkPath = Join-Path $env:RUNNER_TEMP "benchmark.beancount"
          $random = New-Object System.Random(42)
          $accounts = @(
              "Assets:Bank:Checking", "Assets:Bank:Savings", "Assets:Investments:Stocks",
              "Liabilities:CreditCard", "Expenses:Food:Groceries", "Expenses:Food:Restaurant",
              "Expenses:Transport:Gas", "Expenses:Utilities:Electric", "Income:Salary", "Equity:Opening-Balances"
          )
          $expenseAccounts = $accounts | Where-Object { $_ -like "Expenses:*" }
          $sourceAccounts = @("Assets:Bank:Checking", "Liabilities:CreditCard")
          $content = @('option "operating_currency" "USD"', '')
          foreach ($acc in $accounts) {
              $content += "2020-01-01 open $acc"
          }
          $content += ''
          $startDate = [DateTime]::new(2020, 1, 1)
          for ($i = 0; $i -lt 10000; $i++) {
              $d = $startDate.AddDays([Math]::Floor($i / 10)).ToString("yyyy-MM-dd")
              $amount = [Math]::Round($random.NextDouble() * 495 + 5, 2)
              $expense = $expenseAccounts[$random.Next($expenseAccounts.Length)]
              $source = $sourceAccounts[$random.Next($sourceAccounts.Length)]
              $content += "$d * `"Payee $($i % 100)`" `"Transaction $i`""
              $content += "  $expense  $amount USD"
              $content += "  $source"
              $content += ''
          }
          $content | Out-File -FilePath $benchmarkPath -Encoding utf8
          Write-Host "Generated benchmark at $benchmarkPath"
      - name: Build with PGO (Unix)
        if: matrix.pgo && runner.os != 'Windows'
        shell: bash
        run: |
          BENCHMARK_PATH="${RUNNER_TEMP}/benchmark.beancount"

          # macOS: Use classic linker to avoid Xcode 15 crashes on long symbol names
          if [ "${{ runner.os }}" = "macOS" ]; then
            export RUSTFLAGS="-C link-arg=-Wl,-ld_classic"
          fi

          # Step 1: Build instrumented binary
          cargo pgo build -- --no-default-features --features bean-compat

          # Step 2: Run workload to collect profile data
          for i in {1..10}; do
            ./target/${{ matrix.target }}/release/rledger-check "$BENCHMARK_PATH" > /dev/null 2>&1
          done

          # Step 3: Build optimized binary using profile data
          cargo pgo optimize build -- --no-default-features --features bean-compat
      - name: Build with PGO (Windows)
        if: matrix.pgo && runner.os == 'Windows'
        shell: pwsh
        run: |
          $benchmarkPath = Join-Path $env:RUNNER_TEMP "benchmark.beancount"

          # Step 1: Build instrumented binary
          cargo pgo build -- --no-default-features --features bean-compat

          # Step 2: Run workload to collect profile data
          for ($i = 0; $i -lt 10; $i++) {
            & "./target/${{ matrix.target }}/release/rledger-check.exe" $benchmarkPath | Out-Null
          }

          # Step 3: Build optimized binary using profile data
          cargo pgo optimize build -- --no-default-features --features bean-compat
      - name: Build without PGO (cross-compiled targets)
        if: ${{ !matrix.pgo }}
        shell: bash
        run: |
          if [ "${{ matrix.cross }}" = "true" ]; then
            cross build --release --target ${{ matrix.target }} --no-default-features --features bean-compat
          else
            cargo build --release --target ${{ matrix.target }} --no-default-features --features bean-compat
          fi
      - name: Package (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          cd target/${{ matrix.target }}/release

          # Get version from tag (RELEASE_TAG is set at workflow level)
          VERSION=$RELEASE_TAG

          # Create archive with all binaries
          ARCHIVE="rustledger-${VERSION}-${{ matrix.target }}.tar.gz"
          tar -czvf "../../../${ARCHIVE}" \
            rledger-check rledger-format rledger-query rledger-report rledger-doctor rledger-extract rledger-price \
            bean-check bean-format bean-query bean-report bean-doctor bean-extract bean-price

          # Create checksum
          cd ../../..
          shasum -a 256 "$ARCHIVE" > "${ARCHIVE}.sha256"
      - name: Package (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          cd target/${{ matrix.target }}/release

          # Get version from tag (RELEASE_TAG is set at workflow level)
          $VERSION = $env:RELEASE_TAG

          # Create archive with all binaries
          $ARCHIVE = "rustledger-${VERSION}-${{ matrix.target }}.zip"
          $binaries = @(
            "rledger-check.exe", "rledger-format.exe", "rledger-query.exe", "rledger-report.exe", "rledger-doctor.exe", "rledger-extract.exe", "rledger-price.exe",
            "bean-check.exe", "bean-format.exe", "bean-query.exe", "bean-report.exe", "bean-doctor.exe", "bean-extract.exe", "bean-price.exe"
          )
          Compress-Archive -Path $binaries -DestinationPath "../../../${ARCHIVE}"

          # Create checksum
          cd ../../..
          (Get-FileHash -Algorithm SHA256 $ARCHIVE).Hash.ToLower() + "  " + $ARCHIVE | Out-File -Encoding utf8 "${ARCHIVE}.sha256"
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rustledger-${{ matrix.target }}
          path: |
            rustledger-*.tar.gz
            rustledger-*.zip
            rustledger-*.sha256
  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_TAG }}
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true
      - name: List artifacts
        run: ls -la artifacts/
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          draft: false
          generate_release_notes: true
          files: |
            artifacts/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # Update Homebrew tap
  update-homebrew:
    name: Update Homebrew formula
    needs: release
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Homebrew tap update
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.WEBSITE_DISPATCH_TOKEN }}
          repository: rustledger/homebrew-rustledger
          event-type: release
          client-payload: '{"version": "${{ env.RELEASE_TAG }}"}'

  # Update Scoop bucket
  update-scoop:
    name: Update Scoop bucket
    needs: release
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Scoop bucket update
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.WEBSITE_DISPATCH_TOKEN }}
          repository: rustledger/scoop-rustledger
          event-type: release
          client-payload: '{"version": "${{ env.RELEASE_TAG }}"}'
  # Publish to crates.io
  publish:
    name: Publish to crates.io
    needs: release
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_TAG }}
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
      - name: Publish crates (in dependency order)
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          # Publish in dependency order with delay between each
          # to allow crates.io to index the previous crate
          # Use || true to continue if crate already exists

          echo "Publishing rustledger-core..."
          cargo publish -p rustledger-core --no-verify || true
          sleep 30

          echo "Publishing rustledger-parser..."
          cargo publish -p rustledger-parser --no-verify || true
          sleep 30

          echo "Publishing rustledger-booking..."
          cargo publish -p rustledger-booking --no-verify || true
          sleep 30

          echo "Publishing rustledger-loader..."
          cargo publish -p rustledger-loader --no-verify || true
          sleep 30

          echo "Publishing rustledger-validate..."
          cargo publish -p rustledger-validate --no-verify || true
          sleep 30

          echo "Publishing rustledger-query..."
          cargo publish -p rustledger-query --no-verify || true
          sleep 30

          echo "Publishing rustledger-plugin..."
          cargo publish -p rustledger-plugin --no-verify || true
          sleep 30

          echo "Publishing rustledger-importer..."
          cargo publish -p rustledger-importer --no-verify || true
          sleep 30

          echo "Publishing rustledger (CLI)..."
          cargo publish -p rustledger --no-verify || true

          echo "All crates published!"
  # Build WASM package (shared by upload-wasm and publish-wasm)
  build-wasm:
    name: Build WASM
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_TAG }}
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown
      - name: Install wasm-pack
        run: curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
      - name: Build WASM package
        run: |
          cd crates/rustledger-wasm
          wasm-pack build --target web --release
      - name: Prepare package
        run: |
          VERSION=${RELEASE_TAG#v}
          cd crates/rustledger-wasm/pkg
          sed -i "s/\"version\": \".*\"/\"version\": \"${VERSION}\"/" package.json
          sed -i 's/"name": "rustledger-wasm"/"name": "@rustledger\/wasm"/' package.json
      - name: Upload WASM artifact
        uses: actions/upload-artifact@v4
        with:
          name: wasm-package
          path: crates/rustledger-wasm/pkg/

  # Upload WASM to GitHub release
  upload-wasm:
    name: Upload WASM to Release
    needs: build-wasm
    runs-on: ubuntu-latest
    steps:
      - name: Download WASM artifact
        uses: actions/download-artifact@v4
        with:
          name: wasm-package
          path: pkg
      - name: Package WASM
        run: |
          VERSION=$RELEASE_TAG
          cd pkg
          tar -czvf "../rustledger-wasm-${VERSION}.tar.gz" .
          cd ..
          shasum -a 256 "rustledger-wasm-${VERSION}.tar.gz" > "rustledger-wasm-${VERSION}.tar.gz.sha256"
      - name: Upload to Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            rustledger-wasm-*.tar.gz
            rustledger-wasm-*.sha256
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # Publish WASM package to npm
  publish-wasm:
    name: Publish to npm
    needs: [release, build-wasm]
    runs-on: ubuntu-latest
    steps:
      - name: Download WASM artifact
        uses: actions/download-artifact@v4
        with:
          name: wasm-package
          path: pkg
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          registry-url: 'https://registry.npmjs.org'
      - name: Update npm for OIDC support
        run: npm install -g npm@latest
      - name: Publish to npm (trusted publishing)
        run: |
          cd pkg
          # Publish to npm (|| true to continue if version already exists)
          npm publish --access public --provenance || true
  # Trigger website rebuild to use new WASM package
  trigger-website:
    name: Trigger website rebuild
    needs: publish-wasm
    runs-on: ubuntu-latest
    steps:
      - name: Trigger website rebuild
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.WEBSITE_DISPATCH_TOKEN }}
          repository: rustledger/rustledger.github.io
          event-type: wasm-release

  # Build and push Docker images
  docker:
    name: Build Docker images
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_TAG }}
      - name: Download musl artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: rustledger-*-linux-musl
          merge-multiple: true
      - name: Extract binaries
        run: |
          VERSION=$RELEASE_TAG
          mkdir -p docker-context/amd64 docker-context/arm64
          tar -xzf "artifacts/rustledger-${VERSION}-x86_64-unknown-linux-musl.tar.gz" -C docker-context/amd64
          tar -xzf "artifacts/rustledger-${VERSION}-aarch64-unknown-linux-musl.tar.gz" -C docker-context/arm64
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Generate Dockerfile
        run: |
          cat > docker-context/Dockerfile << 'EOF'
          FROM scratch
          ARG TARGETARCH
          COPY ${TARGETARCH}/* /usr/local/bin/
          ENTRYPOINT ["rledger-check"]
          EOF
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/rustledger/rustledger
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=latest
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: docker-context
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  # Publish MCP server to npm
  publish-mcp:
    name: Publish MCP server to npm
    needs: publish-wasm
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_TAG }}
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          registry-url: 'https://registry.npmjs.org'
      - name: Update npm for OIDC support
        run: npm install -g npm@latest
      - name: Wait for npm registry propagation
        run: |
          VERSION=${RELEASE_TAG#v}
          echo "Waiting for @rustledger/wasm@$VERSION to be available on npm..."
          for i in {1..12}; do
            if npm view @rustledger/wasm@$VERSION version 2>/dev/null; then
              echo "Package available!"
              exit 0
            fi
            echo "Attempt $i: Package not yet available, waiting 30s..."
            sleep 30
          done
          echo "Package not available after 6 minutes"
          exit 1
      - name: Update version and install dependencies
        run: |
          cd packages/mcp-server
          VERSION=${RELEASE_TAG#v}
          # Update version in package.json
          sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json
          # Update @rustledger/wasm dependency to use npm package
          sed -i 's|"@rustledger/wasm": "file:../../crates/rustledger-wasm/pkg"|"@rustledger/wasm": "^'$VERSION'"|' package.json
          npm install
      - name: Build
        run: |
          cd packages/mcp-server
          npm run build
      - name: Publish to npm (trusted publishing)
        run: |
          cd packages/mcp-server
          # Publish to npm (|| true to continue if version already exists)
          npm publish --access public --provenance || true

  # Update AUR packages
  update-aur:
    name: Update AUR packages
    needs: release
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_TAG }}
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.AUR_SSH_PRIVATE_KEY }}" > ~/.ssh/aur
          chmod 600 ~/.ssh/aur
          echo "Host aur.archlinux.org" >> ~/.ssh/config
          echo "  IdentityFile ~/.ssh/aur" >> ~/.ssh/config
          echo "  User aur" >> ~/.ssh/config
          ssh-keyscan aur.archlinux.org >> ~/.ssh/known_hosts
      - name: Get checksums
        id: checksums
        run: |
          VERSION=${RELEASE_TAG#v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "pkgver=${VERSION//-/_}" >> $GITHUB_OUTPUT

          SHA_X86=$(curl -sL "https://github.com/rustledger/rustledger/releases/download/v${VERSION}/rustledger-v${VERSION}-x86_64-unknown-linux-gnu.tar.gz" | sha256sum | cut -d' ' -f1)
          SHA_ARM=$(curl -sL "https://github.com/rustledger/rustledger/releases/download/v${VERSION}/rustledger-v${VERSION}-aarch64-unknown-linux-gnu.tar.gz" | sha256sum | cut -d' ' -f1)
          SHA_SRC=$(curl -sL "https://github.com/rustledger/rustledger/archive/refs/tags/v${VERSION}.tar.gz" | sha256sum | cut -d' ' -f1)

          echo "sha_x86=$SHA_X86" >> $GITHUB_OUTPUT
          echo "sha_arm=$SHA_ARM" >> $GITHUB_OUTPUT
          echo "sha_src=$SHA_SRC" >> $GITHUB_OUTPUT
      - name: Update rustledger-bin
        run: |
          git clone ssh://aur@aur.archlinux.org/rustledger-bin.git /tmp/aur-bin
          cd /tmp/aur-bin

          # Update PKGBUILD
          cp $GITHUB_WORKSPACE/packaging/aur/rustledger-bin/PKGBUILD .
          sed -i "s/^pkgver=.*/pkgver=${{ steps.checksums.outputs.pkgver }}/" PKGBUILD
          sed -i "s/^sha256sums_x86_64=.*/sha256sums_x86_64=('${{ steps.checksums.outputs.sha_x86 }}')/" PKGBUILD
          sed -i "s/^sha256sums_aarch64=.*/sha256sums_aarch64=('${{ steps.checksums.outputs.sha_arm }}')/" PKGBUILD

          # Generate .SRCINFO using Docker
          docker run --rm -v "$PWD:/pkg" archlinux:latest sh -c \
            "useradd -m builder && chown -R builder:builder /pkg && su builder -c 'cd /pkg && makepkg --printsrcinfo'" > .SRCINFO

          # Commit and push (exit 0 if nothing to commit - skips push)
          git config user.name "rustledger-ci"
          git config user.email "rustledger-ci@users.noreply.github.com"
          git add PKGBUILD .SRCINFO
          git diff --cached --quiet && echo "No changes to commit" && exit 0
          git commit -m "Update to ${{ steps.checksums.outputs.version }}"
          git push
      - name: Update rustledger
        run: |
          git clone ssh://aur@aur.archlinux.org/rustledger.git /tmp/aur-src
          cd /tmp/aur-src

          # Update PKGBUILD
          cp $GITHUB_WORKSPACE/packaging/aur/rustledger/PKGBUILD .
          sed -i "s/^pkgver=.*/pkgver=${{ steps.checksums.outputs.pkgver }}/" PKGBUILD
          sed -i "s/^sha256sums=.*/sha256sums=('${{ steps.checksums.outputs.sha_src }}')/" PKGBUILD

          # Generate .SRCINFO using Docker
          docker run --rm -v "$PWD:/pkg" archlinux:latest sh -c \
            "useradd -m builder && chown -R builder:builder /pkg && su builder -c 'cd /pkg && makepkg --printsrcinfo'" > .SRCINFO

          # Commit and push (exit 0 if nothing to commit - skips push)
          git config user.name "rustledger-ci"
          git config user.email "rustledger-ci@users.noreply.github.com"
          git add PKGBUILD .SRCINFO
          git diff --cached --quiet && echo "No changes to commit" && exit 0
          git commit -m "Update to ${{ steps.checksums.outputs.version }}"
          git push

  # Update nixpkgs (stable releases only)
  update-nixpkgs:
    name: Update nixpkgs
    needs: release
    runs-on: ubuntu-latest
    # Run for all releases (0.x.y has no hyphens, so this always runs)
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_TAG }}
      - name: Install Nix
        uses: cachix/install-nix-action@v30
      - name: Get hashes
        id: hashes
        run: |
          VERSION=${RELEASE_TAG#v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          # Get source hash
          SRC_HASH=$(nix-prefetch-github rustledger rustledger --rev "v${VERSION}" --json | jq -r .hash)
          echo "src_hash=$SRC_HASH" >> $GITHUB_OUTPUT

          # Get cargo hash by building with fake hash and extracting from error
          cat > /tmp/package.nix << 'PKGEOF'
          { lib, rustPlatform, fetchFromGitHub }:
          rustPlatform.buildRustPackage rec {
            pname = "rustledger";
            version = "VERSION_PLACEHOLDER";
            src = fetchFromGitHub {
              owner = "rustledger";
              repo = "rustledger";
              rev = "v${version}";
              hash = "SRC_HASH_PLACEHOLDER";
            };
            cargoHash = "sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=";
            meta.license = lib.licenses.gpl3Only;
          }
          PKGEOF
          sed -i "s/VERSION_PLACEHOLDER/${VERSION}/" /tmp/package.nix
          sed -i "s|SRC_HASH_PLACEHOLDER|${SRC_HASH}|" /tmp/package.nix

          CARGO_HASH=$(nix-build -E 'with import <nixpkgs> {}; callPackage /tmp/package.nix {}' 2>&1 | grep "got:" | awk '{print $2}') || true
          echo "cargo_hash=$CARGO_HASH" >> $GITHUB_OUTPUT
      - name: Create nixpkgs PR
        env:
          GH_TOKEN: ${{ secrets.WEBSITE_DISPATCH_TOKEN }}
        run: |
          VERSION=${{ steps.hashes.outputs.version }}
          SRC_HASH=${{ steps.hashes.outputs.src_hash }}
          CARGO_HASH=${{ steps.hashes.outputs.cargo_hash }}

          # Fork and clone nixpkgs
          gh repo fork NixOS/nixpkgs --clone --remote
          cd nixpkgs

          # Check if package already exists and get current version
          OLD_VERSION=""
          if [ -f pkgs/by-name/ru/rustledger/package.nix ]; then
            OLD_VERSION=$(grep 'version = "' pkgs/by-name/ru/rustledger/package.nix | head -1 | sed 's/.*version = "\([^"]*\)".*/\1/')
          fi

          # Create branch
          git checkout -b "rustledger-${VERSION}"

          # Create package directory
          mkdir -p pkgs/by-name/ru/rustledger

          # Write package.nix
          cat > pkgs/by-name/ru/rustledger/package.nix << PKGEOF
          {
            lib,
            rustPlatform,
            fetchFromGitHub,
          }:

          rustPlatform.buildRustPackage rec {
            pname = "rustledger";
            version = "${VERSION}";

            src = fetchFromGitHub {
              owner = "rustledger";
              repo = "rustledger";
              rev = "v\${version}";
              hash = "${SRC_HASH}";
            };

            cargoHash = "${CARGO_HASH}";

            meta = with lib; {
              description = "Fast, pure Rust implementation of Beancount double-entry accounting";
              homepage = "https://rustledger.github.io";
              changelog = "https://github.com/rustledger/rustledger/releases/tag/v\${version}";
              license = licenses.gpl3Only;
              maintainers = with maintainers; [ ];
              mainProgram = "rledger-check";
            };
          }
          PKGEOF

          # Determine PR title and body based on whether this is init or update
          if [ -n "$OLD_VERSION" ]; then
            PR_TITLE="rustledger: ${OLD_VERSION} -> ${VERSION}"
            PR_BODY="## Description

          Update [rustledger](https://github.com/rustledger/rustledger) from ${OLD_VERSION} to ${VERSION}.

          [Changelog](https://github.com/rustledger/rustledger/releases/tag/v${VERSION})

          ---
          *Automated PR from rustledger release workflow*"
            COMMIT_MSG="rustledger: ${OLD_VERSION} -> ${VERSION}"
          else
            PR_TITLE="rustledger: init at ${VERSION}"
            PR_BODY="## Description

          Add [rustledger](https://github.com/rustledger/rustledger), a fast pure Rust implementation of Beancount double-entry accounting.

          - 10x faster than Python beancount
          - Full Beancount syntax compatibility
          - Single binary, no Python dependencies

          ## Things done

          - Built on x86_64-linux
          - Tested basic functionality

          ---
          *Automated PR from rustledger release workflow*"
            COMMIT_MSG="rustledger: init at ${VERSION}"
          fi

          # Commit and push
          git config user.name "rustledger-ci"
          git config user.email "rustledger-ci@users.noreply.github.com"
          git add pkgs/by-name/ru/rustledger/package.nix
          git commit -m "$COMMIT_MSG"
          git push -u origin "rustledger-${VERSION}"

          # Create PR
          gh pr create \
            --repo NixOS/nixpkgs \
            --title "$PR_TITLE" \
            --body "$PR_BODY"

  # Trigger COPR build (Fedora/RHEL)
  # COPR is configured to build from SCM (GitHub) with spec file at packaging/rpm/rustledger.spec
  # This job triggers a rebuild when a new release is tagged
  update-copr:
    name: Trigger COPR build
    needs: release
    runs-on: ubuntu-latest
    steps:
      - name: Install copr-cli
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip
          pip3 install copr-cli
      - name: Configure COPR
        run: |
          mkdir -p ~/.config
          cat > ~/.config/copr << 'EOF'
          [copr-cli]
          login = ${{ secrets.COPR_LOGIN }}
          username = robcohen
          token = ${{ secrets.COPR_TOKEN }}
          copr_url = https://copr.fedorainfracloud.org
          EOF
      - name: Trigger SCM build
        run: |
          # Trigger a build using COPR's SCM integration
          # The project is configured to fetch from GitHub and use packaging/rpm/rustledger.spec
          copr-cli build-package robcohen/rustledger \
            --name rustledger \
            --nowait || true

  # Upload to Launchpad PPA (Ubuntu/Debian)
  update-ppa:
    name: Upload to PPA
    needs: release
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ env.RELEASE_TAG }}
      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y devscripts debhelper dput gnupg rustc cargo
      - name: Setup GPG key
        run: |
          echo "${{ secrets.LAUNCHPAD_GPG_PRIVATE_KEY }}" | gpg --batch --import
          # Get key ID and set trust
          KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -1 | awk '{print $2}' | cut -d'/' -f2)
          echo "${KEY_ID}:6:" | gpg --import-ownertrust
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.LAUNCHPAD_SSH_PRIVATE_KEY }}" > ~/.ssh/launchpad
          chmod 600 ~/.ssh/launchpad
          cat >> ~/.ssh/config << EOF
          Host ppa.launchpad.net
            IdentityFile ~/.ssh/launchpad
            User rustledger
          EOF
          ssh-keyscan ppa.launchpad.net >> ~/.ssh/known_hosts
      - name: Configure dput
        run: |
          cat > ~/.dput.cf << EOF
          [rustledger-ppa]
          fqdn = ppa.launchpad.net
          method = sftp
          incoming = ~rustledger/ubuntu/rustledger/
          login = rustledger
          allow_unsigned_uploads = 0
          EOF
      - name: Build and upload source package
        run: |
          VERSION=${RELEASE_TAG#v}
          # Convert version: 1.0.0-rc.18 -> 1.0.0~rc.18 for Debian
          DEB_VERSION=$(echo "$VERSION" | sed 's/-/~/g')

          # Create source tarball
          TARBALL="rustledger_${DEB_VERSION}.orig.tar.gz"
          git archive --format=tar.gz --prefix="rustledger-${DEB_VERSION}/" HEAD > "../${TARBALL}"

          # Extract and prepare
          cd ..
          tar -xzf "${TARBALL}"
          cd "rustledger-${DEB_VERSION}"

          # Copy debian directory
          cp -r $GITHUB_WORKSPACE/packaging/debian .

          # Update changelog for each Ubuntu series
          for SERIES in noble jammy focal; do
            # Update changelog using heredoc to avoid YAML issues
            cat > /tmp/changelog_entry << CHLOG
          rustledger (${DEB_VERSION}-1~${SERIES}1) ${SERIES}; urgency=medium

            * Update to version ${VERSION}

           -- rustledger <rustledger@users.noreply.github.com>  $(date -R)

          CHLOG
            cat /tmp/changelog_entry debian/changelog > /tmp/new_changelog
            mv /tmp/new_changelog debian/changelog

            # Build source package
            debuild -S -sa -k"$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -1 | awk '{print $2}' | cut -d'/' -f2)"

            # Upload to PPA
            dput rustledger-ppa "../rustledger_${DEB_VERSION}-1~${SERIES}1_source.changes" || true

            # Restore original changelog for next series
            git checkout debian/changelog
          done
